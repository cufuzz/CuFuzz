#include <stdio.h>
#include <stdlib.h>
#include <cuda.h>
#include <nvjpeg.h>

void UT(const unsigned char* jpgData, size_t fileSize, nvjpegHandle_t nvjpegHandle, nvjpegJpegState_t nvjpegState, cudaStream_t stream) {
    if (jpgData == NULL || fileSize == 0) return;

    cudaEvent_t startEvent, endEvent;
    cudaEventCreate(&startEvent);
    cudaEventCreate(&endEvent);

    // Removed nvjpegDecodeParamsCreate as it was causing compilation errors

    // Removed nvjpegEncoderStateCreate as it was causing compilation errors

    int nComponents = 0;
    nvjpegChromaSubsampling_t subsampling;
    int widths[NVJPEG_MAX_COMPONENT] = {0};
    int heights[NVJPEG_MAX_COMPONENT] = {0};

    nvjpegStatus_t status = nvjpegGetImageInfo(nvjpegHandle, jpgData, fileSize, &nComponents, &subsampling, widths, heights);
    if (status != NVJPEG_STATUS_SUCCESS) {
        return;
    }

    int out_channels = 3;
    int out_width = widths[0];
    int out_height = heights[0];

    nvjpegImage_t out_img;
    memset(&out_img, 0, sizeof(out_img));

    for (int i = 0; i < out_channels; i++) {
        if (cudaMalloc(&out_img.channel[i], out_width * out_height) != cudaSuccess) {
            for (int j = 0; j < i; j++) {
                cudaFree(out_img.channel[j]);
            }
            return;
        }
        out_img.pitch[i] = out_width;
    }

    status = nvjpegDecode(nvjpegHandle, nvjpegState, jpgData, fileSize, NVJPEG_OUTPUT_RGB, &out_img, stream);
    if (status != NVJPEG_STATUS_SUCCESS) {
        for (int i = 0; i < out_channels; i++) {
            cudaFree(out_img.channel[i]);
        }
        return;
    }

    cudaStreamSynchronize(stream);

    unsigned char* host_channel = (unsigned char*)malloc(out_width * out_height);
    if (host_channel) {
        cudaMemcpy(host_channel, out_img.channel[0], out_width * out_height, cudaMemcpyDeviceToHost);
        free(host_channel);
    }

    for (int i = 0; i < out_channels; i++) {
        cudaFree(out_img.channel[i]);
    }
}

int main(int argc, char* argv[]) {
    const char* filename;
    if (argc > 1) {
        filename = argv[1];
    } else {
        return EXIT_FAILURE;
    }

    nvjpegHandle_t nvjpegHandle;
    nvjpegJpegState_t nvjpegState;
    cudaStream_t stream;

    if (nvjpegCreate(NVJPEG_BACKEND_DEFAULT, NULL, &nvjpegHandle) != NVJPEG_STATUS_SUCCESS) {
        return EXIT_FAILURE;
    }
    if (nvjpegJpegStateCreate(nvjpegHandle, &nvjpegState) != NVJPEG_STATUS_SUCCESS) {
        nvjpegDestroy(nvjpegHandle);
        return EXIT_FAILURE;
    }
    if (cudaStreamCreate(&stream) != cudaSuccess) {
        nvjpegJpegStateDestroy(nvjpegState);
        nvjpegDestroy(nvjpegHandle);
        return EXIT_FAILURE;
    }

    FILE* file = fopen(filename, "rb");
    if (!file) {
        nvjpegJpegStateDestroy(nvjpegState);
        nvjpegDestroy(nvjpegHandle);
        cudaStreamDestroy(stream);
        return EXIT_FAILURE;
    }

    fseek(file, 0, SEEK_END);
    long fileSize = ftell(file);
    fseek(file, 0, SEEK_SET);

    unsigned char* jpgData = (unsigned char*)malloc(fileSize);
    size_t bytesRead = fread(jpgData, 1, fileSize, file);
    fclose(file);

    if (bytesRead != fileSize) {
        free(jpgData);
        nvjpegJpegStateDestroy(nvjpegState);
        nvjpegDestroy(nvjpegHandle);
        cudaStreamDestroy(stream);
        return EXIT_FAILURE;
    }

    UT(jpgData, fileSize, nvjpegHandle, nvjpegState, stream);

    free(jpgData);
    cudaStreamDestroy(stream);
    nvjpegJpegStateDestroy(nvjpegState);
    nvjpegDestroy(nvjpegHandle);

    return EXIT_SUCCESS;
}