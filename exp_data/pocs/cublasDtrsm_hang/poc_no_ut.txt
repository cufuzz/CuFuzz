#include <stdio.h> 
#include <stdlib.h> 
#include <cuda_runtime.h> 
#include <cublas_v2.h> 

// Kernel function definition 
__global__ void mykernel(double *data, int numElements) { 
    int idx = threadIdx.x + blockIdx.x * blockDim.x; 
    if (idx < numElements) { 
        data[idx] *= 2; 
    } 
} 

int main() { 
    // Variable definitions and initialization 
    int numElements = 178; 
    int blockSize = 234; 
    size_t size = numElements * sizeof(double); 

    // Host memory allocation and initialization 
    double *h_data = (double *)malloc(size); 
    for (int i = 0; i < numElements; i++) { 
        h_data[i] = i; 
    } 

    // Device memory allocation 
    double *d_data = nullptr; 
    cudaMalloc((void**)&d_data, size); 

    // cuBLAS handle creation 
    cublasHandle_t handle; 
    cublasCreate(&handle); 

    // 1. Memory copy from host to device 
    cudaMemcpyAsync(d_data, h_data, size, cudaMemcpyHostToDevice, 0); 

    // 2. cuBLAS operation: cublasDtrsm 
    double alpha = 1.0; 
    cublasDtrsm(handle, CUBLAS_SIDE_LEFT, CUBLAS_FILL_MODE_LOWER, CUBLAS_OP_N, CUBLAS_DIAG_NON_UNIT, numElements, numElements, &alpha, d_data, numElements, d_data, numElements); 

    // 3. Kernel launch 
    int numBlocks = (numElements + blockSize - 1) / blockSize; 
    mykernel<<<numBlocks, blockSize>>>(d_data, numElements); 

    // 4. Memory copy from device to host 
    cudaMemcpyAsync(h_data, d_data, size, cudaMemcpyDeviceToHost, 0); 

    // 5. Device synchronization 
    cudaDeviceSynchronize(); 

    // Cleanup 
    cublasDestroy(handle); 
    free(h_data); 
    cudaFree(d_data); 

    return EXIT_SUCCESS; 
}
