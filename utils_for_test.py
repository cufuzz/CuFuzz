import json
import subprocess
import re
from pdf2text import *
import shlex
import os
from transformers import  AutoTokenizer
from enum import Enum
class FResult(Enum):
    SAFE = 1  # validation returns okay
    FAILURE = 2  # validation contains error (something wrong with validation)
    ERROR = 3  # validation returns a potential error (look into)
    LLM_WEAKNESS = (
        4  # the generated input is ill-formed due to the weakness of the language model
    )
    TIMED_OUT = 10  # timed out, can be okay in certain targets


def read_the_json(json_path:str):
    count = 0
    with open(json_path, 'r', encoding='utf-8') as file:
        for line in file:
            count += 1
            try:
                # 尝试解析每一行为JSON对象
                data = json.loads(line)
                # 打印读取到的数据
                print(json.dumps(data, indent=4, ensure_ascii=False))
            except json.JSONDecodeError as e:
                # 如果解析出错，打印错误信息
                print(f"Error parsing JSON line: {e}")
    print(f"\nTotal number of valid JSON lines: {count}")


def save_harness(time_flame:str, the_code:str):
    the_code = the_code.replace('\\n', '\n').replace('%s\n', '%s\\n').replace('%d\n', '%s\\n')

    with open(time_flame, 'w', encoding='utf-8') as file:
        file.write(the_code)
        file.close()

def compile_code(compilation, suffix= None):
    compile_command = shlex.split(compilation)
    insert_idx = 0
    for i in range(len(compile_command)):
        if "_" in compile_command[i]:
            if 'wrap' not in suffix:
                if ".cu" in compile_command[i]:
                    compile_command[i] = compile_command[i][:-3] + suffix + ".cu"
                else:
                    compile_command[i] = compile_command[i] + suffix
            else:
                if ".cu" in compile_command[i]:
                    compile_command[i] = compile_command[i][:-3] + suffix + ".cu"
                    insert_idx = i + 1
                else:
                    compile_command[i] = compile_command[i] + suffix
    if (insert_idx):
        compile_command.insert(insert_idx, f"{os.getcwd()}/c_factors/mu2.o")

    try:
        result = subprocess.run(compile_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,
                                    check=True)
        print(f"       Compilation successful: {compile_command}")
        # print(result)
        return True
    except subprocess.CalledProcessError as e:
        result = e.stderr
        print(result)
        print(f"       Compilation failed: {compile_command}")
        return False

def check_api_within_h(api_name, h_folder = "/usr/local/cuda/include"):
    command = f"grep -ri '{api_name}[^A-Za-z0-9]' {h_folder}"
    try:
        result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        if result.returncode == 0:
            return True
        else:
            return False
    except subprocess.CalledProcessError as e:
        print(f"An error occurred: {e}")
        return False


def get_fake_api(error_messages):
    """
    From the compilation error message, get undefined api generated by llm, and check it within cuda .h file.
    """
    undefined_apis = []
    pattern = re.compile(r'"([^"]+)"\s+is undefined')
    lines = error_messages.split('\n')

    for line in lines:
        match = pattern.search(line)
        if match:
            api_name = match.group(1)
            if not check_api_within_h(api_name):
                undefined_apis.append(api_name)

    return undefined_apis


def check_api_within_manual(api_names, the_manual):
    """
    check the api signature within given manual
    """
    for one_api in api_names:
        for line in the_manual.split('\n'):
            if one_api in line:
                print(line)



def get_arguement_fix(error_messages, the_code_file, mode):
    """
    From the compilation error message and the harness code, checke manu, gain the correct signature to fix harness
    """
    function_names = {}   ##  the api name which has arguments error, need to check its signature within manual
    lines_to_check = []

    if mode == 'rt':
        with open('./rt-lib/pdf2json/rt_api_manual_dict.pkl', 'rb') as f:
            rt_api_signature_dict = pickle.load(f)
        pattern = r'cuda\w+\('

    if mode == 'nvjpeg':
        with open('./nvjpeg/tutorial2json/nvjpeg_api_sig_dict.pkl', 'rb') as f:
            rt_api_signature_dict = pickle.load(f)
        pattern = r'nvjpeg\w+\('

    if mode in ['cublas', 'cufft', 'curand', 'cusolver', 'cusparse']:
        with open(f'./{mode}/pdf2json/{mode}_api_sig_dict.pkl', 'rb') as f:
            rt_api_signature_dict = pickle.load(f)
        if mode == 'cublas':
            pattern = r'cublas\w+\('
        if mode == 'cufft':
            pattern = r'cufft\w+\('
        if mode == 'curand':
            pattern = r'curand\w+\('
        if mode == 'cusolver':
            pattern = r'cusolver\w+\('
        if mode == 'cusparse':
            pattern = r'cusparse\w+\('

    lines = error_messages.split('\n')
    for line in lines:
        if 'argument' in line:
            match = re.search(r'\.cu\((\d+)\)', line)
            if match:
                lines_to_check.append(match.group(1))

    # pattern = r'cuda\w+\('
    with open(the_code_file, 'r') as file:
        lines = file.readlines()
        for line_number, line in enumerate(lines, start=1):
            if str(line_number) in lines_to_check and re.search(pattern, line):
                # 使用正则表达式找到函数名
                match = re.search(pattern, line)
                if match:
                    # 提取函数名并存储到字典中
                    the_api_name = match.group(0)[:-1]
                    if the_api_name in rt_api_signature_dict:
                        function_names[the_api_name] = rt_api_signature_dict[the_api_name]

    return function_names, lines_to_check

def search_signature(api_name_list, mode):
    with open('./rt-lib/pdf2json/rt_api_manual_dict.pkl', 'rb') as f:
        rt_api_signature_dict_rt = pickle.load(f)

    if mode == 'nvjpeg':
        with open('./nvjpeg/tutorial2json/nvjpeg_api_sig_dict.pkl', 'rb') as f:
            api_signature_dict_nvjpeg = pickle.load(f)

    if (mode != 'rt') and (mode != 'nvjpeg'):
        with open(f'./{mode}/pdf2json/{mode}_api_sig_dict.pkl', 'rb') as f:
            api_sig_dict_mode = pickle.load(f)

    sig_list = []

    for api in api_name_list:
        if api in rt_api_signature_dict_rt:
            if isinstance(rt_api_signature_dict_rt[api], list):
                sig_list.append(rt_api_signature_dict_rt[api][0])
            else:
                sig_list.append(rt_api_signature_dict_rt[api])
            break

        if mode == 'nvjpeg':
            if api in api_signature_dict_nvjpeg:
                if isinstance(api_signature_dict_nvjpeg[api], list):
                    sig_list.append(api_signature_dict_nvjpeg[api][0])
                else:
                    sig_list.append(api_signature_dict_nvjpeg[api])
        else:
            if mode != 'rt':
                if api in api_sig_dict_mode:
                    if isinstance(api_sig_dict_mode[api], list):
                        sig_list.append(api_sig_dict_mode[api][0])
                    else:
                        sig_list.append(api_sig_dict_mode[api])

    return sig_list


def crawl_nvjpeg_webpage_save():
    import requests
    from bs4 import BeautifulSoup

    page_url = f"https://docs.nvidia.com/cuda/nvjpeg/index.html"

    response = requests.get(page_url)

    if response.status_code == 200:
        # 使用BeautifulSoup解析网页内容
        soup = BeautifulSoup(response.text, 'html.parser')

        # print(soup.prettify())

        content_div = soup.find('div', class_='document')  # 假设主要内容在 <div class="document"> 中

        # 检查是否找到了目标元素
        if content_div:
            # 提取文本内容
            # content = content_div.get_text()
            content_html = str(content_div)

            # 保存到txt文件
            with open('nvjpeg_documentation.html', 'w', encoding='utf-8') as file:
                file.write(content_html)

            print("网页内容已成功保存到 nvjpeg_documentation.html 文件中")
        else:
            print("未找到包含主要内容的HTML元素，请检查网页结构")

    else:
        print(f"请求失败，状态码：{response.status_code}")


def count_tokens_with_transformers(file_path, model_name='bert-base-uncased'):
    """
    使用transformers库计算指定文件中的token数量。

    :param file_path: 输入文件的路径
    :param model_name: 使用的预训练模型名称
    :return: 文件中的token数量
    """
    # 加载预训练模型的分词器
    tokenizer = AutoTokenizer.from_pretrained(model_name)

    # 初始化token计数器
    token_count = 0

    # 打开文件并逐行读取
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            # 使用分词器对每一行进行token化
            tokens = tokenizer.tokenize(line)
            # 更新token计数器
            token_count += len(tokens)

    return token_count


def parse_fuzz_output(the_path):
    """
    given the harness path, execute the harness binary and wrapped binary.
    determine if it is a genuine bug, and cat the harness.
    the_path must comforms the format as ./xxx/xxx/xxx
    """
    the_name = os.path.basename(the_path)
    command_origin = f'{the_path}/{the_name}'
    result = subprocess.run(command_origin, shell=True, text=True, capture_output=True)
    print(f'{the_name} output: {result.stdout}')
    print(f'{the_name} error report: {result.stderr}')

    command_warpper = f"./{the_path[2:]}/{the_name}_sep_wrap"
    result = subprocess.run(command_warpper, shell=True, text=True, capture_output=True)
    print(f'{the_name}_sep_wrap output: {result.stdout}')
    print(f'{the_name}_sep_wrap error report: {result.stderr}')
    env = os.environ.copy()

    for i in range(1):
        if i%10 == 0 : print(i)
        process = subprocess.Popen(
            command_warpper,
            # shell=True,
            stdout=subprocess.PIPE,  # 捕获标准输出
            stderr=subprocess.PIPE,  # 捕获标准错误
            text=True,  # 输出以字符串形式处理
            bufsize=1,
            env=env,
            cwd=os.path.dirname(command_warpper)
        )
        stdout, stderr = process.communicate()
        return_code = process.returncode
        if process.returncode != 0:
            print(f'wrapper stdout and stderr: {stdout}, {stderr} | wrapper return code: {FResult.ERROR }')

        else:
            if i % 10== 0 :
                print(f'wrapper stdout and stderr: {stdout}, {stderr} | wrapper return code: {FResult.SAFE}')



    command_cat = f'cat {the_path}/{the_name}.cu'
    result = subprocess.run(command_cat, shell=True, text=True, capture_output=True)
    print(f'{the_name}.cu : {result.stdout}')


def parse_array_declaration(declaration):
    # parse a array variable, return array name and array length
    pattern = r"(\w+)\s*\[([^\]]*)\]"
    match = re.match(pattern, declaration)

    if match:
        # 提取变量名和数组长度
        variable_name = match.group(1)
        array_length = match.group(2)

        try:
            array_length = eval(array_length)
        except (NameError, SyntaxError):
            pass

        return variable_name, array_length
    else:
        return None, None


def compile_code111(complie_line):
    compile_command = complie_line
    try:
        result = subprocess.run(compile_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,
                                    check=True)
        print(f"   Compilation successful: {compile_command}")
        compile_result = result.stdout + '\n' + result.stderr
        print(compile_result)
        return True
    except subprocess.CalledProcessError as e:
        print(f"   Compilation failed: {compile_command}")
        result = e.stderr
        compile_result = result
        print(compile_result)
        return False

if __name__ == "__main__":
    # test_list = ['20250401_230254', '20250401_230143', '20250401_230925', '20250402_095143', '20250403_025811']
    #
    # for item in test_list:
    #
    #     root_path = f'./harness/{item}'
    #     parse_fuzz_output(root_path)

    # aa = ['cudaMemcpyFromSymbol', 'cudaMemcpyToSymbol', 'cudaMalloc', 'cudaGraphCreate', 'cudaGraphConditionalHandleCreate', 'cudaGraphAddNode', 'cudaStreamUpdateCaptureDependencies']
    # bb = search_signature(aa, 'nvjpeg')
    # print(bb)

    aa =['/usr/local/cuda/bin/nvcc', './rt-lib/harness/20250520_204555/20250520_204555.cu', '-o', './rt-lib/harness/20250520_204555/20250520_204555']
    compile_code111(aa)

   
